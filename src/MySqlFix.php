<?php
declare(strict_types=1);

namespace SetBased\ErdConcepts;

/**
 * Class for fixing issues in SQL code generated by ERD Concepts with MySQL as target database.
 */
class MySqlFix
{
  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Maximum length of column comments in MySQL.
   */
  const MAX_COLUMN_COMMENT_LENGTH = 1024;

  /**
   * Maximum length of table comments in MySQL.
   */
  const MAX_TABLE_COMMENT_LENGTH = 2048;

  /**
   * Maximum length of index comments in MySQL.
   */
  const MAX_INDEX_COMMENT_LENGTH = 1024;

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Add comments to column definitions based on commented column comments.
   *
   * @param string $source The SQL code generated by ERD concepts.
   *
   * @return string
   */
  public static function fixColumnComments(string $source): string
  {
    $lines = explode(PHP_EOL, $source);

    // Map from (table_name,column_name) to line number
    $map = [];

    // Scan the source for column definitions.
    $tableName = null;
    foreach ($lines as $i => $line)
    {
      if (isset($tableName))
      {
        if (preg_match('/^ {2}(?<column>`?\w+`?)/', $line, $matches))
        {
          $map[$tableName][$matches['column']] = $i;
        }
        else
        {
          $tableName = null;
        }
      }

      if ($tableName===null && preg_match('/^CREATE TABLE (?<table>`?\w+`?)/', $line, $matches))
      {
        $tableName = $matches['table'];
      }
    }

    // Scan the source for comments.
    $comments = [];
    foreach ($lines as $i => $line)
    {
      if (preg_match('/^COMMENT ON COLUMN (?<table>`?\w+`?).(?<column>`?\w+`?)/', $line, $matches))
      {
        $comment = self::extractComment($lines, $i, self::MAX_COLUMN_COMMENT_LENGTH);
        if ($comment!=='')
        {
          $comments[$matches['table']][$matches['column']] = $comment;
        }
      }
    }

    // Enhance the column definitions with comments.
    foreach ($comments as $tableName => $columns)
    {
      if (!isset($map[$tableName]))
      {
        throw new \RuntimeException(sprintf("Table '%s' is not defined.", $tableName));
      }

      foreach ($columns as $columnName => $comment)
      {
        if (!isset($map[$tableName][$columnName]))
        {
          throw new \RuntimeException(sprintf("Column '%s' is not defined in '%s' table statements.",
                                              $columnName,
                                              $tableName));
        }

        $lineNumber = $map[$tableName][$columnName];

        // Truncate comments longer than 60 characters.
        if (strlen($comment)>self::MAX_COLUMN_COMMENT_LENGTH)
        {
          $comment = trim(mb_substr($comment, 0, self::MAX_COLUMN_COMMENT_LENGTH - 3)).'...';
        }

        // Enhance the column definition with comment.
        $lines[$lineNumber] = rtrim($lines[$lineNumber]);
        if (str_ends_with($lines[$lineNumber], ','))
        {
          $lines[$lineNumber] = mb_substr($lines[$lineNumber], 0, -1);
          $last               = ',';
        }
        else
        {
          $last = '';
        }
        $lines[$lineNumber] .= " COMMENT '".self::escapeMysqlString($comment)."'".$last;
      }
    }

    return implode(PHP_EOL, $lines);
  }


  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Add comments to index definitions based on commented index comments.
   *
   * @param string $source The SQL code generated by ERD concepts.
   *
   * @return string
   */
  public static function fixIndexComments(string $source): string
  {
    $lines = explode(PHP_EOL, $source);

    // Map from (table_name,column_name) to line number
    $map = [];

    // Scan the source for column definitions.
    $index_name = null;
    foreach ($lines as $i => $line)
    {
      if (preg_match('/^CREATE (UNIQUE )?INDEX (?<index>`?\w+`?)(\s*\()?/', $line, $matches))
      {
        $map[$matches['index']] = $i;
      }
    }

    // Scan the source for comments.
    $comments = [];
    foreach ($lines as $i => $line)
    {
      if (preg_match('/^COMMENT ON INDEX (?<index>`?\w+`?)/', $line, $matches))
      {
        $comment = self::extractComment($lines, $i, self::MAX_INDEX_COMMENT_LENGTH);
        if ($comment!=='')
        {
          $comments[$matches['index']] = $comment;
        }
      }
    }

    // Enhance the column definitions with comments.
    foreach ($comments as $indexName => $comment)
    {
      if (!isset($map[$indexName]))
      {
        throw new \RuntimeException(sprintf("Index '%s' is not defined.", $indexName));
      }

      $lineNumber = $map[$indexName];

      // Truncate comments longer than 60 characters.
      if (strlen($comment)>self::MAX_COLUMN_COMMENT_LENGTH)
      {
        $comment = trim(mb_substr($comment, 0, self::MAX_COLUMN_COMMENT_LENGTH - 3)).'...';
      }

      // Enhance the column definition with comment.
      $lines[$lineNumber] = mb_substr(rtrim($lines[$lineNumber]), 0, -1);
      $lines[$lineNumber] .= " COMMENT '".self::escapeMysqlString($comment)."';";
    }

    return implode(PHP_EOL, $lines);
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Add comments to table definitions based on commented table comments.
   *
   * @param string $source The SQL code generated by ERD concepts.
   *
   * @return string
   */
  public static function fixTableComments(string $source): string
  {
    $lines = explode(PHP_EOL, $source);

    // Map from (table_name,column_name) to line number
    $map = [];

    // Scan the source for column definitions.
    $table_name = null;
    $level      = 0;
    foreach ($lines as $i => $line)
    {
      if (isset($table_name))
      {
        if (preg_match('/[)(]/', $line, $matches))
        {
          if ($matches[0]=='(')
          {
            $level = +1;
          }
          if ($matches[0]==')')
          {
            $level = -1;
          }

          if ($level<0)
          {
            $map[$table_name] = $i;
            $table_name       = null;
          }
        }
      }

      if ($table_name===null && preg_match('/^CREATE TABLE (?<table>`?\w+`?)(\s*\()?/', $line, $matches))
      {
        $table_name = $matches[1];
        if ($matches['table'])
        {
          $level = 1;
        }
      }
    }

    // Scan the source for comments.
    $comments = [];
    foreach ($lines as $i => $line)
    {
      if (preg_match('/^COMMENT ON TABLE (?<table>`?\w+`?)/', $line, $matches))
      {
        $comment = self::extractComment($lines, $i, self::MAX_TABLE_COMMENT_LENGTH);
        if ($comment!=='')
        {
          $comments[$matches['table']] = $comment;
        }
      }
    }

    // Enhance the column definitions with comments.
    foreach ($comments as $table_name => $comment)
    {
      if (!isset($map[$table_name]))
      {
        throw new \RuntimeException(sprintf("Table '%s' is not defined.", $table_name));
      }

      $line_number = $map[$table_name];

      // Truncate comments longer than 1024 characters.
      if (strlen($comment)>self::MAX_COLUMN_COMMENT_LENGTH)
      {
        $comment = trim(mb_substr($comment, 0, self::MAX_COLUMN_COMMENT_LENGTH - 3)).'...';
      }

      // Enhance the column definition with comment.
      if (mb_substr(rtrim($lines[$line_number]), -1)===';')
      {
        $lines[$line_number] = mb_substr(rtrim($lines[$line_number]), 0, -1);
        $lines[$line_number] .= " COMMENT '".self::escapeMysqlString($comment)."';";
      }
      else
      {
        $lines[$line_number] .= " COMMENT '".self::escapeMysqlString($comment)."'";
      }
    }

    return implode(PHP_EOL, $lines);
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Escapes special characters in a string for use in an SQL statement.
   *
   * @param string $string The string that is to be escaped.
   *
   * @return string
   */
  protected static function escapeMysqlString(string $string): string
  {
    // We prefer to use mysqli::escape_string but this method requires a connection. Since ERD Concepts generates
    // SQL code in UTF-8 and $unescaped_string is not user input (from the evil internet) we can safely use addslashes.
    return addslashes($string);
  }

  //--------------------------------------------------------------------------------------------------------------------
  /**
   * Extracts a commented comment.
   *
   * @param array $lines     The SQL code generated by ERD concepts as an array of lines.
   * @param int   $index     The line number of the comment statement.
   * @param int   $maxLength The max length of the comment.
   *
   * @return string
   */
  private static function extractComment(array $lines, int $index, int $maxLength): string
  {
    $comment = '';

    if ($index>=1 && $lines[$index - 1]==='/*')
    {
      $j = $index + 1;
      while ($j<sizeof($lines) && $lines[$j]!=='*/')
      {
        $comment .= $lines[$j];
        $comment .= PHP_EOL;

        $j++;
      }
    }

    $comment = trim($comment);
    if (mb_strlen($comment)>$maxLength)
    {
      $comment = trim(mb_substr($comment, 0, $maxLength - 3)).'...';
    }

    return $comment;
  }

  //--------------------------------------------------------------------------------------------------------------------
}

//----------------------------------------------------------------------------------------------------------------------
